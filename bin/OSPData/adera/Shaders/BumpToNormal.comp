/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(location = 0, r8) uniform readonly image2D heightmap;
layout(location = 1, rgba8) uniform writeonly image2D normalField;

layout(location = 2) uniform float circumference;
layout(location = 3) uniform float oblateness;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 START = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
ivec2 UV = ivec2(START + gl_LocalInvocationID.xy);
const float PI = 3.14159265359;

// TODO oblateness
float trueV = float(UV.y) / float(gl_NumWorkGroups.y*gl_WorkGroupSize.y);
vec2 trueUV = vec2(UV) / vec2(DIMS);
float circAtLatitude = circumference*sin((1.0 - trueV) * PI);
float dLat = circumference / float(DIMS.y);
float dLong = circAtLatitude / (DIMS.x);

/**
 * NASA LOLA data is converted to 16-bit unsigned ints
 *
 * Each unit corresponds to a half meter relative to a radius of
 * 1737.4km. Thus, the values may be converted to kilometers by
 * dividing by 2*1000
 */
float read_in(int xOset, int yOset)
{
    uint shortMax = 0xFFFF;
    float normValue = imageLoad(heightmap, UV + ivec2(xOset, yOset)).r;
    float altitudeKm = (normValue*shortMax) / 2000.0;
    return altitudeKm;
}

vec3 compute_normal()
{
    float north = read_in(0, 1);
    float south = read_in(0, -1);
    float east = read_in(1, 0);
    float west = read_in(-1, 0);

    float dEdU = (east - west)/(2.0*dLong);
    float dNdV = (north - south)/(2.0*dLat);
    vec3 grad = vec3(1.0, -dEdU, -dNdV);
    return normalize(grad);
}

vec3 transform_normal(vec3 normal)
{
    float longitude = float(UV.x)/float(DIMS.x) - 0.5;
    float latitude = float(UV.y)/float(DIMS.y) - 0.5;
    float phi = longitude * 2.0*PI;
    float theta = (-latitude) * PI;

    mat3 transform =  
        mat3(
            cos(phi), sin(phi), 0.0,
            -sin(phi), cos(phi),  0.0,
            0.0,      0.0,       1.0)
      * mat3(
            cos(theta),  0.0, -sin(theta),
            0.0,         1.0, 0.0,
            sin(theta), 0.0, cos(theta));

    return transform * normal;
}

vec3 bias_vec3_rgb(vec3 xyz)
{
    return (xyz + vec3(1.0)) / 2.0;
}

/**
 * Convert range [-1, 1] to [0, 1]
 */
void write_normal(vec3 tangentSpace)
{
    vec3 biased = bias_vec3_rgb(tangentSpace);
    imageStore(normalField, UV, vec4(biased, 1.0));
}

void main()
{
    vec3 normalWorld = transform_normal(compute_normal());
    write_normal(normalWorld);
}
