/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(location = 0, r8) uniform readonly image2D heightmap;
layout(location = 1, rgba8) uniform writeonly image2D normalField;

layout(location = 2) uniform float circumference;
layout(location = 3) uniform float oblateness;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 START = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
ivec2 UV = ivec2(START + gl_LocalInvocationID.xy);
const float PI = 3.14159265359;

// TODO oblateness
float trueV = float(UV.y) / float(gl_NumWorkGroups.y*gl_WorkGroupSize.y);
vec2 trueUV = vec2(UV) / vec2(DIMS);
float circAtLatitude = circumference*sin((1.0 - trueV) * PI);
float dLat = circumference / float(DIMS.y);
float dLong = circAtLatitude / float(DIMS.x);

/**
 * NASA LOLA data is converted to 16-bit unsigned ints
 *
 * Each unit corresponds to a half meter relative to a radius of
 * 1737.4km. Thus, the values may be converted to kilometers by
 * dividing by 2*1000
 */
float read_in(int xOset, int yOset)
{
    uint shortMax = 0xFFFF;

    ivec2 uv0 = UV + ivec2(xOset, yOset);

    if (uv0.x >= int(DIMS.x))
    {
        uv0.x -= int(DIMS.x);
    }
    else if (uv0.x < 0)
    {
        uv0.x += int(DIMS.x);
    }

    if (uv0.y >= int(DIMS.y))
    {
        uv0.y -= int(DIMS.y);
    }
    else if (uv0.y < 0)
    {
        uv0.y += int(DIMS.y);
    }

//    int xWrapPos = int(uv0.x >= DIMS.x);
//    int yWrapPos = int(uv0.y >= DIMS.y);
//    int xWrapNeg = int(uv0.x < 0);
//    int yWrapNeg = int(uv0.y < 0);
//    ivec2 uvWrap = ivec2(
//        uv0.x*(1 - xWrapPos - xWrapNeg) + (uv0.x - DIMS.x)*xWrapPos + (uv0.x + DIMS.x)*xWrapNeg,
//        uv0.y*(1 - yWrapPos - yWrapNeg) + (uv0.y - DIMS.y)*yWrapPos + (uv0.y + DIMS.y)*yWrapNeg
//    );

    float normValue = imageLoad(heightmap, uv0).r;
    float altitudeKm = (normValue*shortMax) / 2000.0;
    return altitudeKm;
}

float quadstep(float edge0, float edge1, float x)
{
    if (x < edge0) { return 0.0; }
    if (x > edge1) { return 1.0; }

    float v = (x - edge0) / (edge1 - edge0);
    return v*v;
}

float polestep(float edge0, float edge1, float v)
{
    return quadstep(edge0, edge1, v) + quadstep(edge0, edge1, 1.0 - v);
}

vec3 compute_normal()
{
    // Temporary fix for imprecision at poles
    int mult = 1;
    if (trueV < 0.1 || trueV > 0.9)
    {
        mult = 1 + int(5.0*polestep(0.9, 1.0, trueV));
    }

    float north = read_in(0, 1);
    float south = read_in(0, -1);
    float east = read_in(1*mult, 0);
    float west = read_in(-1*mult, 0);

    float dEdU = (east - west)/(2.0*dLong*mult);
    float dNdV = (north - south)/(2.0*dLat);
    vec3 grad = vec3(1.0, -dEdU, -dNdV);
    return normalize(grad);
}

vec3 transform_normal(vec3 normal)
{
    float longitude = float(UV.x)/float(DIMS.x) - 0.5;
    float latitude = float(UV.y)/float(DIMS.y) - 0.5;
    float phi = longitude * 2.0*PI;
    float theta = (-latitude) * PI;

    mat3 transform =  
        mat3(
            cos(phi), sin(phi), 0.0,
            -sin(phi), cos(phi),  0.0,
            0.0,      0.0,       1.0)
      * mat3(
            cos(theta),  0.0, -sin(theta),
            0.0,         1.0, 0.0,
            sin(theta), 0.0, cos(theta));

    return transform * normal;
}

vec3 bias_vec3_rgb(vec3 xyz)
{
    return (xyz + vec3(1.0)) / 2.0;
}

/**
 * Convert range [-1, 1] to [0, 1]
 */
void write_normal(vec3 tangentSpace)
{
    vec3 biased = bias_vec3_rgb(tangentSpace);
    imageStore(normalField, UV, vec4(biased, 1.0));
}

void main()
{
    vec3 normalWorld = transform_normal(compute_normal());
    write_normal(normalWorld);
}
