/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(location = 0, r8) uniform readonly image2D heightmap;
layout(location = 1, rgba8) uniform writeonly image2D normalField;

layout(location = 2) uniform float circumference;
layout(location = 3) uniform float oblateness;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 START = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
ivec2 UV = ivec2(START + gl_LocalInvocationID.xy);
const float PI = 3.14159265359;

// TODO oblateness
float trueV = float(UV.y) / float(gl_NumWorkGroups.y*gl_WorkGroupSize.y);
float circAtLatitude = circumference*sin((1.0 - trueV) * PI);
float dLat = circumference / float(DIMS.y);
float dLong = circAtLatitude / (DIMS.x);

/**
 * NASA LOLA data is converted to 16-bit unsigned ints
 *
 * Each unit corresponds to a half meter relative to a radius of
 * 1737.4km. Thus, the values may be converted to kilometers by
 * dividing by 2*1000
 */
float read_in(int xOset, int yOset)
{
    uint shortMax = 0xFFFF;
    float normValue = imageLoad(heightmap, UV + ivec2(xOset, yOset)).r;
    float altitudeKm = (normValue*shortMax) / 2000.0;
    return altitudeKm;
}

vec3 compute_normal()
{
    float north = read_in(0, 1);
    float south = read_in(0, -1);
    float east = read_in(1, 0);
    float west = read_in(-1, 0);

    float dEdU = (east - west)/(2.0*dLong);
    float dNdV = (north - south)/(2.0*dLat);
    vec3 grad = vec3(-dEdU, -dNdV, 1.0);
    return normalize(grad);
}

/**
 * Convert range [-1, 1] to [0, 1]
 */
vec4 encode_normal(vec3 tangentSpace)
{
    return vec4((tangentSpace + vec3(1.0)) * vec3(0.5), 1.0);
}

void main()
{
    vec3 normalXYZ = compute_normal();
    imageStore(normalField, UV, encode_normal(normalXYZ));
}
