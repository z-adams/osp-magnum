/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

/**
 * Compile-time parameters:

 * DATATYPE
    - FLOAT (vec4, image*)
    - UINT (uvec4, uimage*)
    - INT (ivec4, iimage*)

 * FORMAT_QUAL
    - r32f, rg32f, rgba8ui, etc
*/

// ==== Don't touch these ====
#define FLOAT 1
#define UINT 2
#define INT 3

#if DATATYPE == FLOAT
#define GIMAGE_INPUT image2D
#define GIMAGE_OUTPUT imageCube
#define VALUE_TYPE vec4
#elif DATATYPE == UINT
#define GIMAGE_INPUT uimage2D
#define GIMAGE_OUTPUT uimageCube
#define VALUE_TYPE uvec4
#elif DATATYPE == INT
#define GIMAGE_INPUT iimage2D
#define GIMAGE_OUTPUT iimageCube
#define VALUE_TYPE ivec4
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(location = 0, FORMAT_QUAL) uniform readonly GIMAGE_INPUT equirectangular;
layout(location = 1, FORMAT_QUAL) uniform writeonly GIMAGE_OUTPUT cube;

const float PI = 3.14159265359;

uvec2 START = gl_WorkGroupID.xy * gl_WorkGroupSize.xy;
uvec2 UV = START + gl_LocalInvocationID.xy;
uint CUBE_FACE = gl_WorkGroupID.z;

/**
 * Copies the specified source pixel from the equirectangular map to the
 * specified destination pixel in the cubemap
 */
void do_sample(ivec2 srcPixel, ivec3 destPixel)
{
    VALUE_TYPE value = imageLoad(equirectangular, srcPixel);

    imageStore(cube, destPixel, value);
}

/**
 * Converts a Cubemap face ID and texture coordinate to 3D vector
 *
 * BLACK MAGIC WARNING
 * OpenGL's cubemap coordinates are wack (that's a technical term). The
 * specification describes them as left-handed, Y-up coordinates, but my
 * experiments seem to indicate that they're right-handed coordinates rotated
 * 90 degrees about X. In any case, to complicate matters further, planet
 * textures are cubemaps viewed from the outside, whereas normal cubemaps are
 * meant to be viewed from the inside.
 * Long story short, I have no theoretical explanation for the coordinate
 * transformation below. It was obtained empirically and seems to work, so
 * edit at your own peril.
 *
 * @param faceID [in] An index to a CubeMap face, according to the OpenGL spec
 * @param uv     [in] A UV coordinate of the given face
 *
 * @return A 3-vector in right-handed Z-up cartesian coordinates pointing
           towards the specified cubemap pixel
 */
vec3 cube_uv_to_xyz_slow(in uint faceID, in vec2 uv)
{
    float uc = 2.0*uv.x - 1.0;
    float vc = 2.0*uv.y - 1.0;

    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (faceID == 0)
    {  // posX (RH +X)
        x = 1.0;
        y = uc;
        z = -vc;
    }
    else if (faceID == 1)
    {  // negX (RH -X)
        x = -1.0;
        y = -uc;
        z = -vc;
    }
    else if (faceID == 2)
    {  // posY (RH +Z)
        x = uc;
        y = -vc;
        z = 1.0;
    }
    else if (faceID == 3)
    {  // negY (RH -Z)
        x = uc;
        y = vc;
        z = -1.0;
    }
    else if (faceID == 4)
    {  // posZ (RH -Y)
        x = uc;
        y = -1.0;
        z = -vc;
    }
    else if (faceID == 5)
    {  // negZ (RH +Y)
        x = -uc;
        y = 1.0;
        z = -vc;
    }

    return normalize(vec3(x, y, z));
}

/**
 * A branch-free version of cube_uv_to_xyz_slow()
 */
vec3 cube_uv_to_xyz(in uint faceID, in vec2 uv)
{
    float uc = 2.0*uv.x - 1.0;
    float vc = 2.0*uv.y - 1.0;

    float posX = float(faceID == 0);
    float negX = float(faceID == 1);
    float posY = float(faceID == 2);
    float negY = float(faceID == 3);
    float posZ = float(faceID == 4);
    float negZ = float(faceID == 5);

    float x = 1.0    *posX
            + (-1.0) *negX
            + uc     *posY
            + uc     *negY
            + uc     *posZ
            + (-uc)  *negZ;

    float y = uc     *posX
            + (-uc)  *negX
            + (-vc)  *posY
            + vc     *negY
            + (-1.0) *posZ
            + 1.0    *negZ;

    float z = -vc    *posX
            + (-vc)  *negX
            + 1.0    *posY
            + (-1.0) *negY
            + (-vc)  *posZ
            + (-vc)  *negZ;

    return normalize(vec3(x, y, z));
}

/**
 * Converts cartesian vector XYZ to spherical surface (theta, phi) coordinates
 */
vec2 xyz_to_sphere_angles(vec3 xyz)
{
    float r = length(xyz);
    float theta = acos(xyz.z / r);
    float phi = atan(xyz.y, xyz.x);

    return vec2(theta, phi);
}

/**
 * Coverts spherical angles to flat UV map coordinates
 *
 * This function maps geographic coordinates to simple UV coordinates that are
 * used to index the equirectangular map texture.
 *
 * Equirectangular maps are simple projections that are indexed by spherical
 * angles. The center of the map represents (0, 0) lat/long, the horizontal (U)
 * direction maps to longitudes beloging to (-pi, pi), and the vertical
 * direction (V) maps to latitudes belonging to (0, pi) (where 0 degrees
 * latitude is the top of the image)
 */
vec2 spherical_to_equirectangular_uv(vec2 thetaPhi)
{
    float phi = thetaPhi.y;
    float theta = thetaPhi.x;

    float u = phi / (2*PI) + 0.5;
    float v = 1.0 - (theta / PI);

    return vec2(u, v);
}

/**
 * Generate a debug cubemap
 *
 * Given a cubemap face ID, generates a color according to the following table:

   FACE ID |   COLOR   |  VALUE
    0 (+X) | RED       | (255, 0, 0)
    1 (+Y) | GREEN     | (0, 255, 0)
    2 (+Z) | BLUE      | (0, 0, 255)
    3 (-X) | 1 - RED   | (0, 255, 255)
    4 (-Y) | 1 - GREEN | (255, 0, 255)
    5 (-Z) | 1 - BLUE  | (255, 255, 0)
 */
uvec3 debug_color(uint face)
{
    uint isPosX = uint(face == 0);
    uint isNegX = uint(face == 1);
    uint isPosY = uint(face == 2);
    uint isNegY = uint(face == 3);
    uint isPosZ = uint(face == 4);
    uint isNegZ = uint(face == 5);

    uvec3 posX = {255, 0, 0};
    uvec3 negX = {0, 255, 255};
    uvec3 posY = {0, 255, 0};
    uvec3 negY = {255, 0, 255};
    uvec3 posZ = {0, 0, 255};
    uvec3 negZ = {255, 255, 0};

    return isPosX*posX
         + isNegX*negX
         + isPosY*posY
         + isNegY*negY
         + isPosZ*posZ
         + isNegZ*negZ;
}

void main()
{
    uvec2 outputDims = imageSize(cube);
    uvec2 inputDims = imageSize(equirectangular);

    // Destination cubemap pixel coordinate
    ivec3 dest = ivec3(UV.x, UV.y, CUBE_FACE);

    vec2 cubeUV = (vec2(UV) + vec2(0.5)) / float(outputDims.x);
    vec3 vector = cube_uv_to_xyz(CUBE_FACE, cubeUV);
    vec2 angles = xyz_to_sphere_angles(vector);
    vec2 eqNorm = spherical_to_equirectangular_uv(angles);

    // Source equirectangular map pixel coordinate
    ivec2 src = ivec2(inputDims.x*eqNorm.x, inputDims.y*eqNorm.y);

    do_sample(src, dest);
}
