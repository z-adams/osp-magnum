/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 32) in;

const uint THREAD_INDEX = gl_GlobalInvocationID.x;
const uint N_INVOCATIONS = gl_NumWorkGroups.x*gl_WorkGroupSize.x;

layout(location = 0) uniform uvec3 counts;
const uint N_POINTS = counts.x;
const uint N_POINTS_PADDED = counts.y;
const uint OUTPUT_OSET = counts.z;

layout(binding = 0, std430) readonly buffer RawInput
{
    double rawInput[];
};

struct ColorVert
{
    vec4 position;
    vec4 color;
};

layout(binding = 1, std430) buffer PointLocations
{
    ColorVert pointVerts[];
};

void interpret_input_points(uint index)
{
    double x_i = rawInput[0*N_POINTS_PADDED + index];
    double y_i = rawInput[1*N_POINTS_PADDED + index];
    double z_i = rawInput[2*N_POINTS_PADDED + index];

    const double invUnit = 1.0LF / 1024.0LF;
    const double scalingFactor = 1e-6LF;
    vec3 result = vec3(dvec3(x_i, y_i, z_i) * invUnit * scalingFactor);
    pointVerts[OUTPUT_OSET + index].position = vec4(result, 1.0);
}

void main()
{
    if (THREAD_INDEX > N_POINTS) { return; }
    interpret_input_points(THREAD_INDEX);
}
