/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

#define ORBIT_SAMPLES 512

layout(local_size_x = ORBIT_SAMPLES) in;

const uint PATH_SAMPLE = gl_GlobalInvocationID.x;
const uint PATH_ID = gl_GlobalInvocationID.y;
const uint N_PATHS = gl_NumWorkGroups.y;
const uvec2 DIMS = gl_WorkGroupSize.xy*gl_NumWorkGroups.xy;
const uvec2 XY = gl_GlobalInvocationID.xy;
const uint N_INVOCATIONS = DIMS.x * DIMS.y;

layout(location = 0) uniform uvec4 pathDataCounts;
const uint N_POINTS = pathDataCounts.x;
//const uint N_PATHS = pathDataCounts.y;
const uint N_PATH_VERTS = pathDataCounts.z;
const uint N_PATH_INDICES = pathDataCounts.w;

layout(binding = 0, std430) readonly buffer RawInput
{
    double rawInput[];
};

struct ColorVert
{
    vec4 position;
    vec4 color;
};

/**
 * A buffer containing the current location of all map bodies
 * 
 * This corresponds to MapRenderData::m_pointBuffer and is filled each frame
 * by passing raw orbital timestep data to the MapPositionsConverter compute
 * shader which populates the buffer that is then bound here. These point
 * locations are pushed into the trail buffers by this kernel.
*/
layout(binding = 1, std430) buffer PointLocations
{
    ColorVert pointVerts[];
};

/**
 * A buffer containing the vertices used to draw map trails and paths
 *
 * Corresponds to MapRenderData::m_vertexBuffer
 */
layout(binding = 2, std430) buffer PathData
{
    ColorVert pathData[];
};

/**
 * A buffer containing the indices used to draw map trails and paths
 *
 * The path drawing relies on GL's "primitive restart" functionality, which
 * allows a magic index value to indicate the interruption of the primitive
 * (e.g. line strip) being drawn. Corresponds to MapRenderData::m_indexBuffer
 */
layout(binding = 3, std430) buffer PathIndices
{
    uint indices[];
};

struct PathMetadata
{
    uint pointIndex;  // Index of this path's origin in PointLocations
    uint startIdx;    // Start of this path's index data in PathIndices
    uint endIdx;      // End of this path's index data in PathIndices
    uint nextIdx;     // The next vertex index to become the first
};

layout(binding = 4) buffer PathsInfo
{
    PathMetadata paths[];
};

/**
 * Fade the alpha of all trail vertices
 *
 * On each execution, the alpha value of all trail vertices is slightly
 * reduced, giving a fading effect. Call this before new vertices are pushed,
 * or you'll be prematurely dimming them.
 */
void fade_color(uint pathID, uint pathVertID)
{
    uint index = pathID*ORBIT_SAMPLES + pathVertID;
    float alpha = pathData[index].color.a;
    pathData[index].color.a = clamp(alpha - 0.002, 0.0, 1.0);
}

/**
 * Increment all path indices
 *
 * On each execution, the path mesh vertices are all incremented (except for
 * the primitive restart one). With every new vertex that's pushed, the mesh
 * indices are shifted up one to allow the newly pushed vertex to be the first
 * one in the trail.
 */
void inc_index(uint pathID, uint pathVertID)
{
    // Increment all indices (except the primitive restart one at the end)
    const uint nIndices = ORBIT_SAMPLES + 1;
    uint index = pathID*nIndices + pathVertID;
    indices[index]++;

    // Bound check
    uint begin = paths[pathID].startIdx;
    uint end = paths[pathID].endIdx;
    if (indices[index] > end)
    {
        indices[index] = begin;
    }
}

/**
 * Push the point vertices onto the trail mesh
 *
 * The point locations represent the current location of each body. Their
 * positions can be used to draw the latest segment of trail.
 */
void path_step(uint pathID)
{
    PathMetadata path = paths[pathID];

    vec3 newPos = pointVerts[path.pointIndex].position.xyz;
    uint newPathVertIdx = indices[path.nextIdx];
    pathData[newPathVertIdx].position = vec4(newPos, 1.0);

    path.nextIdx++;
    if (path.nextIdx > path.endIdx)
    {
        path.nextIdx = path.startIdx;
    }
}

void main()
{
    // 1. Fade colors of all existing path verts
    fade_color(PATH_ID, PATH_SAMPLE);

    // 2. Increment all indices
    inc_index(PATH_ID, PATH_SAMPLE);

    // Exit all threads except 1 per path (TODO: try using just the 1st path group)
    if (PATH_SAMPLE > 0) { return; }

    // 3. Use point sprite positions to update paths
    path_step(PATH_ID);
}
