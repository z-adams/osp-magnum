/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 64, local_size_y = 1) in;

// Constants to be filled at runtime:
uint PATH_SAMPLE = 0;
uint PATH_ID = 0;
uint NUM_PATH_VERTS = 0;
uint NUM_PATH_INDICES = 0;

struct ColorVert
{
    vec4 position;
    vec4 color;
};

/**
 * A buffer containing the current location of all map bodies
 * 
 * This corresponds to MapRenderData::m_pointBuffer and is filled each frame
 * by passing raw orbital timestep data to the MapPositionsConverter compute
 * shader which populates the buffer that is then bound here. These point
 * locations are pushed into the trail buffers by this kernel.
*/
layout(binding = 0, std430) buffer PointLocations
{
    ColorVert pointVerts[];
};

/**
 * A buffer containing the vertices used to draw map trails and paths
 *
 * Corresponds to MapRenderData::m_vertexBuffer
 */
layout(binding = 1, std430) buffer PathData
{
    ColorVert pathData[];
};

/**
 * A buffer containing the indices used to draw map trails and paths
 *
 * The path drawing relies on GL's "primitive restart" functionality, which
 * allows a magic index value to indicate the interruption of the primitive
 * (e.g. line strip) being drawn. Corresponds to MapRenderData::m_indexBuffer
 */
layout(binding = 2, std430) buffer PathIndices
{
    uint indices[];
};

struct PathMetadata
{
    uint pointIndex;  // Index of this path's origin in PointLocations
    uint startIdx;    // Start of this path's index data in PathIndices
    uint endIdx;      // End of this path's index data in PathIndices
    uint nextIdx;     // The next vertex index to become the first
};

layout(binding = 3, std430) buffer PathsInfo
{
    PathMetadata paths[];
};

layout(binding = 4, std430) buffer PathGroupBoundaries
{
    uint pathBoundaries[];
};

// Operation enum
#define OP_SKIP 0x1
#define OP_PUSH 0x2
#define OP_FADE 0x4

bool flag_is_set(uint value, uint flag)
{
    return (value & flag) > 0;
}

layout(binding = 5, std430) buffer PathOperationBuffer
{
    uint operations[];
};

/**
 * Calculates the work item to be handled by this thread.
 * 
 * Since paths may have variable lengths, the group must search through a list
 * of boundaries in order to bin itself into the right path, and calculate the
 * sample ID of each thread within that path. It also calculates the number of
 * vertices and indices spanned by that path.
 */
void find_work_item()
{
    const uint groupID = gl_WorkGroupID.x;

    uint boundaryIdx = 0;
    for (int i = pathBoundaries.length() - 1; i > 0; i--)
    {
        if (groupID >= pathBoundaries[i])
        {
            PATH_ID = i;
            break;
        }
    }
    uint pathSubgroupIndex = groupID - pathBoundaries[PATH_ID];
    PATH_SAMPLE = gl_LocalInvocationID.x + gl_WorkGroupSize.x * pathSubgroupIndex;
    PathMetadata path = paths[PATH_ID];
    NUM_PATH_VERTS = path.endIdx - path.startIdx + 1;
    NUM_PATH_INDICES = NUM_PATH_VERTS + 1;
}

/**
 * Fade the alpha of all trail vertices
 *
 * On each execution, the alpha value of all trail vertices is slightly
 * reduced, giving a fading effect. Call this before new vertices are pushed,
 * or you'll be prematurely dimming them.
 */
void fade_color(uint pathID, uint pathVertID)
{
    PathMetadata path = paths[pathID];
    uint index = path.startIdx + pathVertID;
    float alpha = pathData[index].color.a;
    float rate = 1.0 / float(NUM_PATH_VERTS - 1);
    pathData[index].color.a = clamp(alpha - rate, 0.0, 1.0);
}

/**
 * Increment all path indices
 *
 * On each execution, the path mesh vertices are all incremented (except for
 * the primitive restart one). With every new vertex that's pushed, the mesh
 * indices are shifted up one to allow the newly pushed vertex to be the first
 * one in the trail.
 */
void inc_index(uint pathID, uint pathVertID)
{
    PathMetadata path = paths[pathID];
    uint index = path.startIdx + pathVertID;
    indices[index]++;

    // Bound check
    uint begin = path.startIdx;
    uint end = path.endIdx;
    if (indices[index] > end)
    {
        indices[index] = begin;
    }
}

/**
 * Push the point vertices onto the trail mesh
 *
 * The point locations represent the current location of each body. Their
 * positions can be used to draw the latest segment of trail.
 */
void path_push_step(uint pathID)
{
    PathMetadata path = paths[pathID];

    ColorVert newVert = pointVerts[path.pointIndex];
    vec3 newPos = newVert.position.xyz;
    uint newPathVertIdx = path.nextIdx;
    pathData[newPathVertIdx].position = vec4(newPos, 1.0);
    pathData[newPathVertIdx].color = newVert.color;

    path.nextIdx++;
    if (path.nextIdx > path.endIdx)
    {
        path.nextIdx = path.startIdx;
    }
    // Write path index back to buffer
    paths[pathID].nextIdx = path.nextIdx;
}

void update_trail(uint pathID, uint sampleID)
{
    // 1. Increment all indices
    inc_index(pathID, sampleID);

    // 2. Fade colors of all existing path verts
    /* We skip fading the vertex that will become the front vertex this frame.
       It may seem like a waste to branch on this condition, but since the fade
       and push operations happen within different work groups, there will be
       memory coherency issues if they both try to modify the same vertex.
     */
    if (flag_is_set(operations[pathID], OP_FADE))
    {
        PathMetadata path = paths[pathID];
        uint frontIndex = path.nextIdx - path.startIdx;
        if (sampleID != frontIndex)
        {
            fade_color(pathID, sampleID);
        }
    }

    // Exit all threads except 1 per path (TODO: try using just the 1st path group)
    if (sampleID > 0) { return; }

    // 3. Use point sprite positions to update paths
    path_push_step(pathID);
}

/*void update_predicted_path(uint pathID, uint sampleID)
{
    // 1. Increment all indices
    inc_index(pathID, sampleID);

    // Exit all threads except 1 per path (TODO: try using just the 1st path group)
    if (sampleID > 0) { return; }

    // 2. Push incremental path update
    path_push_step(pathID);
}*/

void main()
{
    // Set up thread
    find_work_item();

    // Discard threads that are out of bounds, or paths that are skipped
    if ((PATH_SAMPLE >= NUM_PATH_VERTS) || flag_is_set(operations[PATH_ID], OP_SKIP))
    {
        return;
    }

    update_trail(PATH_ID, PATH_SAMPLE);
}
