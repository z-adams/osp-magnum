/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 64, local_size_y = 1) in;

// Constants to be filled at runtime:
uint PATH_SAMPLE = 0;
uint PATH_ID = 0;
uint NUM_PATH_VERTS = 0;
uint NUM_PATH_INDICES = 0;

struct ColorVert
{
    vec4 position;
    vec4 color;
};

/**
 * A buffer containing the current location of all map bodies
 * 
 * This corresponds to MapRenderData::m_pointBuffer and is filled each frame
 * by passing raw orbital timestep data to the MapPositionsConverter compute
 * shader which populates the buffer that is then bound here. These point
 * locations are pushed into the trail buffers by this kernel.
*/
layout(binding = 0, std430) buffer PointLocations
{
    ColorVert pointVerts[];
};

/**
 * A buffer containing the vertices used to draw map trails and paths
 *
 * Corresponds to MapRenderData::m_vertexBuffer
 */
layout(binding = 1, std430) buffer PathData
{
    ColorVert pathData[];
};

/**
 * A buffer containing the indices used to draw map trails and paths
 *
 * The path drawing relies on GL's "primitive restart" functionality, which
 * allows a magic index value to indicate the interruption of the primitive
 * (e.g. line strip) being drawn. Corresponds to MapRenderData::m_indexBuffer
 */
layout(binding = 2, std430) buffer PathIndices
{
    uint indices[];
};

struct PathMetadata
{
    uint pointIndex;  // Index of this path's origin in PointLocations
    uint startIdx;    // Start of this path's index data in PathIndices
    uint endIdx;      // End of this path's index data in PathIndices
    uint nextIdx;     // The next vertex index to become the first
};

layout(binding = 3, std430) buffer PathsInfo
{
    PathMetadata paths[];
};

layout(binding = 4, std430) buffer PathGroupBoundaries
{
    uint pathBoundaries[];
};

/**
 * Calculates the work item to be handled by this thread.
 * 
 * Since paths may have variable lengths, the group must search through a list
 * of boundaries in order to bin itself into the right path, and calculate the
 * sample ID of each thread within that path. It also calculates the number of
 * vertices and indices spanned by that path.
 */
void find_work_item()
{
    const uint groupID = gl_WorkGroupID.x;

    uint boundaryIdx = 0;
    for (int i = pathBoundaries.length() - 1; i > 0; i--)
    {
        if (groupID >= pathBoundaries[i])
        {
            PATH_ID = i;
            break;
        }
    }
    uint pathSubgroupIndex = groupID - pathBoundaries[PATH_ID];
    PATH_SAMPLE = gl_LocalInvocationID.x + gl_WorkGroupSize.x * pathSubgroupIndex;
    PathMetadata path = paths[PATH_ID];
    NUM_PATH_VERTS = path.endIdx - path.startIdx + 1;
    NUM_PATH_INDICES = NUM_PATH_VERTS + 1;
}

/**
 * Fade the alpha of all trail vertices
 *
 * On each execution, the alpha value of all trail vertices is slightly
 * reduced, giving a fading effect. Call this before new vertices are pushed,
 * or you'll be prematurely dimming them.
 */
void fade_color(uint pathID, uint pathVertID)
{
    uint index = pathID*NUM_PATH_INDICES + pathVertID;
    float alpha = pathData[index].color.a;
    float rate = 1.0 / float(NUM_PATH_VERTS - 1);
    pathData[index].color.a = clamp(alpha - rate, 0.0, 1.0);
}

/**
 * Increment all path indices
 *
 * On each execution, the path mesh vertices are all incremented (except for
 * the primitive restart one). With every new vertex that's pushed, the mesh
 * indices are shifted up one to allow the newly pushed vertex to be the first
 * one in the trail.
 */
void inc_index(uint pathID, uint pathVertID)
{
    // Increment all indices (except the primitive restart one at the end)
    uint index = pathID*NUM_PATH_INDICES + pathVertID;
    indices[index]++;

    // Bound check
    uint begin = paths[pathID].startIdx;
    uint end = paths[pathID].endIdx;
    if (indices[index] > end)
    {
        indices[index] = begin;
    }
}

/**
 * Push the point vertices onto the trail mesh
 *
 * The point locations represent the current location of each body. Their
 * positions can be used to draw the latest segment of trail.
 */
void path_push_step(uint pathID)
{
    PathMetadata path = paths[pathID];

    ColorVert newVert = pointVerts[path.pointIndex];
    vec3 newPos = newVert.position.xyz;
    // TODO bug: get index of vertex, not index
    uint newPathVertIdx = path.nextIdx;
    pathData[newPathVertIdx].position = vec4(newPos, 1.0);
    pathData[newPathVertIdx].color = newVert.color;

    path.nextIdx++;
    if (path.nextIdx > path.endIdx)
    {
        path.nextIdx = path.startIdx;
    }
    // Write path index back to buffer
    paths[pathID].nextIdx = path.nextIdx;
}

void update_trail(uint pathID, uint sampleID)
{
    // 1. Fade colors of all existing path verts
    fade_color(pathID, sampleID);

    // 2. Increment all indices
    inc_index(pathID, sampleID);

    // Exit all threads except 1 per path (TODO: try using just the 1st path group)
    if (sampleID > 0) { return; }

    // 3. Use point sprite positions to update paths
    path_push_step(pathID);
}

void update_predicted_path(uint pathID, uint sampleID)
{
    // 1. Increment all indices
    inc_index(pathID, sampleID);

    // Exit all threads except 1 per path (TODO: try using just the 1st path group)
    if (sampleID > 0) { return; }

    // 2. Push incremental path update
    path_push_step(pathID);
}

void main()
{
    // Set up thread
    find_work_item();

    // Discard threads that are out of bounds
    if (PATH_SAMPLE >= NUM_PATH_VERTS) { return; }

    update_trail(PATH_ID, PATH_SAMPLE);
}
