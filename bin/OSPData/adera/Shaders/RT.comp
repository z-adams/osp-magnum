/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 UV = gl_GlobalInvocationID.xy;
vec2 uvf = vec2(UV) / vec2(DIMS);

struct OccludingSphere
{
    vec3 position;
    float radius;
};

struct ObjectData
{
    vec3 aabbMaxs;
    uint firstTriIndex;
    vec3 aabbMins;
    uint numTriangles;
};

layout(binding = 0) uniform objects
{
    ObjectData objs[];
};

struct DirectionalLight
{
    vec3 direction;
    float brightness;
};

layout(binding = 1) uniform lightBuf
{
    DirectionalLight lights[];
};

struct GBufPixel
{
    vec3 castRay;
    float sampleDepth;
    vec2 normalXY;
    vec2 hitUV;
};

layout(std430, binding = 3) buffer gBuffer
{
    GBufPixel gBuf[];
};

struct Triangle
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

layout(std430, binding = 4) buffer triangleBuffer
{
    Triangle tris[];
};

layout(binding = 2, r8) uniform writeonly image2D brightnessOut;

// Wikipedia Moller-Trumbore algorithm, GLSL-ified and branches removed
bool RayIntersectsTriangle(vec3 rayOrigin, vec3 rayVector,
    in Triangle inTriangle, out vec3 outIntersectionPoint)
{
    const float EPSILON = 0.0000001;
    vec3 vertex0 = inTriangle.v0;
    vec3 vertex1 = inTriangle.v1;
    vec3 vertex2 = inTriangle.v2;

    // Results: store all tests and decide return value at the end
    // All of them must be true for the intersection to pass
    bool resultA = true,
         resultB = true,
         resultC = true,
         resultHit = false;

    vec3 edge1, edge2, h, s, q;
    float a,f,u,v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    // Test if ray is parallel to this triangle.
    resultA = !(a > -EPSILON && a < EPSILON);

    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * dot(s, h);
    resultB =  !(u < 0.0 || u > 1.0);

    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    resultC =  !(v < 0.0 || u + v > 1.0);

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    outIntersectionPoint = rayOrigin + rayVector * t;
    resultHit = (t > EPSILON); // ray intersection

    return resultA && resultB && resultC && resultHit;
}

void main()
{
    GBufPixel px = gBuf[UV.y * DIMS.y + UV.x];

    if (px.sampleDepth == 0.0) { return; }
    vec3 ray = px.castRay;
    vec3 normal = vec3(px.normalXY,
        sqrt(1.0 - px.normalXY.x*px.normalXY.x - px.normalXY.y*px.normalXY.y));
    vec2 uv = px.hitUV;

    float lightFacing = 0.0;
    for (uint l = 0; l < lights.length(); l++)
    {
        lightFacing += lights[l].brightness * dot(normal, lights[l].direction);
    }

    imageStore(brightnessOut, ivec2(UV), vec4(lightFacing, 0.0, 0.0, 1.0));
}

