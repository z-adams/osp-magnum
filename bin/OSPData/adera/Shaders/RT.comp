/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 UV = gl_GlobalInvocationID.xy;
vec2 uvf = vec2(UV) / vec2(DIMS);

struct OccludingSphere
{
    vec3 position;
    float radius;
};

struct ObjectData
{
    mat4 transform;
    vec3 aabbMaxs;
    uint firstTriIndex;
    vec3 aabbMins;
    uint numTriangles;
};

layout(location = 0) uniform uvec4 counts;

const uint OBJ_COUNT = counts.x;
const uint LIGHT_COUNT = counts.y;
const uint TRI_COUNT = counts.z;

layout(std140, binding = 0) uniform objects
{
    ObjectData objs[64];
};

layout(std140, binding = 1) uniform lightBuf
{
    vec4 lights[1];
};

struct Triangle
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

layout(std430, binding = 2) buffer triangleBuffer
{
    float tris[];
};

Triangle unpack_tri(uint index)
{
    uint begin = index*3*3; // (3 floats x 3 verts) per triangle

    Triangle t;
    t.v0 = vec3(tris[begin + 0], tris[begin + 1], tris[begin + 2]);
    t.v1 = vec3(tris[begin + 3], tris[begin + 4], tris[begin + 5]);
    t.v2 = vec3(tris[begin + 6], tris[begin + 7], tris[begin + 8]);
    return t;
}

layout(location = 1, rgba8) uniform writeonly image2D brightnessOut;
layout(location = 2) uniform sampler2D gRayDepth;
layout(location = 3) uniform sampler2D gNormalUV;
layout(location = 4) uniform vec3 cameraPosWorld;
layout(location = 5) uniform mat3 cameraRot;

struct Box
{
    vec3 mins;
    vec3 maxs;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
    vec3 inv;
};

//tavianator
bool ray_aabb_intersection(Box b, Ray r)
{ 
    float tmin = (b.mins.x - r.origin.x) / r.direction.x; 
    float tmax = (b.maxs.x - r.origin.x) / r.direction.x; 
 
    if (tmin > tmax)
    {
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
    }
 
    float tymin = (b.mins.y - r.origin.y) / r.direction.y; 
    float tymax = (b.maxs.y - r.origin.y) / r.direction.y; 
 
    if (tymin > tymax)
    {
        float tmp = tymin;
        tymin = tymax;
        tymax = tmp;
    }
 
    if ((tmin > tymax) || (tymin > tmax)) 
        return false; 
 
    if (tymin > tmin) 
        tmin = tymin; 
 
    if (tymax < tmax) 
        tmax = tymax; 
 
    float tzmin = (b.mins.z - r.origin.z) / r.direction.z; 
    float tzmax = (b.maxs.z - r.origin.z) / r.direction.z; 
 
    if (tzmin > tzmax)
    {
        float tmp = tzmin;
        tzmin = tzmax;
        tzmax = tmp;
    }
 
    if ((tmin > tzmax) || (tzmin > tmax)) 
        return false; 
 
    if (tzmin > tmin) 
        tmin = tzmin; 
 
    if (tzmax < tmax) 
        tmax = tzmax; 
 
    return true; 
} 

/*{
    float tx1 = (b.mins.x - r.origin.x)*r.inv.x;
    float tx2 = (b.maxs.x - r.origin.x)*r.inv.x;

    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (b.mins.y - r.origin.y)*r.inv.y;
    float ty2 = (b.maxs.y - r.origin.y)*r.inv.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    float tz1 = (b.mins.z - r.origin.z)*r.inv.z;
    float tz2 = (b.maxs.z - r.origin.z)*r.inv.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = max(tmax, max(tz1, tz2));

    return tmax >= tmin;
}*/


// Wikipedia Moller-Trumbore algorithm, GLSL-ified and branches removed
bool ray_triangle_intersection(vec3 rayOrigin, vec3 rayVector,
    in Triangle inTriangle, out vec3 outIntersectionPoint)
/*{
    const float EPSILON = 0.0000001;
    vec3 vertex0 = inTriangle.v0;
    vec3 vertex1 = inTriangle.v1;
    vec3 vertex2 = inTriangle.v2;

    // Results: store all tests and decide return value at the end
    // All of them must be true for the intersection to pass
    bool resultA = true,
         resultB = true,
         resultC = true,
         resultHit = false;

    vec3 edge1, edge2, h, s, q;
    float a,f,u,v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    // Test if ray is parallel to this triangle.
    resultA = !(a > -EPSILON && a < EPSILON);

    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * dot(s, h);
    resultB =  !(u < 0.0 || u > 1.0);

    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    resultC =  !(v < 0.0 || u + v > 1.0);

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    outIntersectionPoint = rayOrigin + rayVector * t;
    resultHit = (t > EPSILON); // ray intersection

    return resultA && resultB && resultC && resultHit;
}*/
{
    const float EPSILON = 0.0000001;
    vec3 vertex0 = inTriangle.v0;
    vec3 vertex1 = inTriangle.v1;
    vec3 vertex2 = inTriangle.v2;

    vec3 edge1 = {0.0, 0.0, 0.0};
    vec3 edge2 = {0.0, 0.0, 0.0};
    vec3 h = {0.0, 0.0, 0.0};
    vec3 s = {0.0, 0.0, 0.0};
    vec3 q = {0.0, 0.0, 0.0};
    float a = 0.0, f = 0.0, u = 0.0, v = 0.0;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    // Test if ray is parallel to this triangle.
    if (a > -EPSILON && a < EPSILON)
    {
        return false;
    }

    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    if (v < 0.0 || u + v > 1.0)
    {
        return false;
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON) // ray intersection
    {
        outIntersectionPoint = rayOrigin + rayVector * t;
        return true;
    }
    return false;
}

vec3 decode(vec3 rgb)
{
    return 2.0*(rgb - vec3(0.5));
}

vec2 decode(vec2 rg)
{
    return 2.0*rg - vec2(1.0);
}

void store(vec4 rgba)
{
    imageStore(brightnessOut, ivec2(UV), rgba);
}

void draw_circle(ivec2 pos)
{
    vec2 r = vec2(pos - ivec2(UV));
    //float doDraw = 10.0 / length(r);
    float doDraw = 1.0 - step(10.0, length(r));
    store(vec4(vec3(doDraw), 1.0));
}

void main()
{
    //imageStore(brightnessOut, ivec2(UV), vec4(vec3(0.0), 1.0));

    //float depth = texture(gRayDepth, uvf).w;
    //if (depth == 1.0) { return; }

    const float HFOV = (3.14159265359/180.0)*45.0;
    const float WIDTH_PX = 1280.0;
    const float HEIGHT_PX = 720.0;
    float VIEW_PLANE_D = (WIDTH_PX/2.0)/tan(HFOV/2.0);
    vec2 rayXY = vec2(UV) - vec2(WIDTH_PX/2.0, HEIGHT_PX/2.0);

    Ray r;
    r.origin = cameraPosWorld;
    r.direction = cameraRot * normalize(vec3(rayXY, -VIEW_PLANE_D));
    r.inv = 1.0 / r.direction;

    store(vec4(r.direction, 1.0));

    Triangle debugTri;
    debugTri.v0 = vec3(-2.0, 0.0, 0.0);
    debugTri.v1 = vec3(2.0, 0.0, 0.0);
    debugTri.v2 = vec3(0.0, 0.0, 4.0);

    vec3 hitPos = vec3(0.0);
    bool hit = ray_triangle_intersection(r.origin, r.direction, debugTri, hitPos);
    if (hit)
    {
        store(vec4(1.0));
    }

    /*for (uint i = 0; i < TRI_COUNT; i++)
    {
        Triangle t = unpack_tri(i);
        vec3 hitPos = vec3(0.0);
        bool hit = ray_triangle_intersection(r.origin, r.direction, t, hitPos);
        if (hit)
        {
            store(vec4(1.0));
        }
    }*/

    /*ObjectData fuselage = objs[17];
    Box aabb;
    aabb.mins = fuselage.aabbMins;
    aabb.maxs = fuselage.aabbMaxs;*/

    /*vec4 vertPos = fuselage.transform * vec4(unpack_tri(tris[fuselage.firstTriIndex]).v0, 1.0);
    vec2 vertPos2D = vertPos.xy;
    ivec2 coords = ivec2(vec2(vertPos2D / vec2(600.0, 5.0) + vec2(0.0, 0.0)) * ivec2(DIMS));
    draw_circle(coords);

    return;
    if (fuselage.transform[3][0] > 300.0)
    {
        store(vec4(1.0));
    }
    return;*/

    /*bool hitBox = ray_aabb_intersection(aabb, r);
    if (hitBox)
    {
        imageStore(brightnessOut, ivec2(UV), vec4(1.0, 0.0, 0.0, 1.0));
        for (uint i = fuselage.firstTriIndex; i < fuselage.firstTriIndex + fuselage.numTriangles; i++)
        {
            Triangle t = unpack_tri(tris[i]);
            Triangle tWorld;
            tWorld.v0 = vec3(fuselage.transform * vec4(t.v0, 1.0));
            tWorld.v1 = vec3(fuselage.transform * vec4(t.v1, 1.0));
            tWorld.v2 = vec3(fuselage.transform * vec4(t.v2, 1.0));

            vec3 hitPos = vec3(0.0);
            bool hitTri = ray_triangle_intersection(r.origin, r.direction, t, hitPos);
            if (hitTri)
            {
                imageStore(brightnessOut, ivec2(UV), vec4(1.0));
            }
        }
    }*/

    /*Box b;
    b.mins = objs[17].aabbMins;
    b.maxs = objs[17].aabbMaxs;

    vec3 intersect = vec3(0.0);
    bool hit = ray_aabb_intersection(b, r);

    vec4 color = vec4((hit)? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0), 1.0);
    imageStore(brightnessOut, ivec2(UV), color);*/

    /*vec2 normal2D = decode(texture(gNormalUV, uvf).xy);
    vec2 uv = decode(texture(gNormalUV, uvf).zw);
    vec3 normal = vec3(normal2D,
        sqrt(1.0 - normal2D.x*normal2D.x - normal2D.y*normal2D.y));*/

    /*for (uint i = 0; i < OBJ_COUNT; i++)
    {
        ObjectData o = objs[i];
        Box aabb;
        aabb.mins = o.aabbMins;
        aabb.maxs = o.aabbMaxs;
        bool hit = ray_aabb_intersection(aabb, r);
        if (hit)
        {
            //vec3 color = cameraPosWorld - vec3(o.transform[3][0], o.transform[3][1], o.transform[3][2]);
            vec3 color = vec3(0.5, 0.0, 0.0);
            //imageStore(brightnessOut, ivec2(UV), vec4(color, 1.0));
            uint start = o.firstTriIndex;
            uint stop = start + o.numTriangles;
            for (uint j = start; j < stop; j++)
            {
                Triangle t = unpack_tri(j);
                Triangle tTransformed;
                tTransformed.v0 = vec3(o.transform * vec4(t.v0, 1.0));
                tTransformed.v1 = vec3(o.transform * vec4(t.v1, 1.0));
                tTransformed.v2 = vec3(o.transform * vec4(t.v2, 1.0));
                vec3 intersect = vec3(0.0);
                bool hitTri = ray_triangle_intersection(r.origin, r.direction, t, intersect);
                if (hitTri)
                {
                    imageStore(brightnessOut, ivec2(UV), vec4(1.0));
                }
            }
        }
    }*/

    //imageStore(brightnessOut, ivec2(UV), vec4(ray, 1.0));
}

