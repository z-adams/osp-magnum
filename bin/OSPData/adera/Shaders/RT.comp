/**
 * Open Space Program
 * Copyright © 2019-2020 Open Space Program Project
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uvec2 DIMS = gl_NumWorkGroups.xy*gl_WorkGroupSize.xy;
uvec2 UV = gl_GlobalInvocationID.xy;
vec2 uvf = vec2(UV) / vec2(DIMS);

struct OccludingSphere
{
    vec3 position;
    float radius;
};

struct ObjectData
{
    mat4 invTransform;
    vec3 aabbMaxs;
    uint firstTriIndex;
    vec3 aabbMins;
    uint numTriangles;
};

layout(location = 0) uniform uvec4 counts;

const uint OBJ_COUNT = counts.x;
const uint LIGHT_COUNT = counts.y;
const uint TRI_COUNT = counts.z;

layout(std140, binding = 0) uniform objects
{
    ObjectData objs[64];
};

layout(std140, binding = 1) uniform lightBuf
{
    vec4 lights[1];
};

struct Triangle
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

layout(std430, binding = 2) buffer triangleBuffer
{
    float tris[];
};

Triangle unpack_tri(uint index)
{
    uint begin = index*3*3; // (3 floats x 3 verts) per triangle

    Triangle t;
    t.v0 = vec3(tris[begin + 0], tris[begin + 1], tris[begin + 2]);
    t.v1 = vec3(tris[begin + 3], tris[begin + 4], tris[begin + 5]);
    t.v2 = vec3(tris[begin + 6], tris[begin + 7], tris[begin + 8]);
    return t;
}

layout(location = 1, rgba8) uniform writeonly image2D brightnessOut;
layout(location = 2) uniform sampler2D gPosDepth;
layout(location = 3) uniform sampler2D gNormalUV;
layout(location = 4) uniform vec3 cameraPosWorld;
layout(location = 5) uniform mat3 cameraRot;

struct Box
{
    vec3 mins;
    vec3 maxs;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
    vec3 inv;
};

/*
branched: 46000 microseconds
branch-free: 99000 microseconds
branch-free bounding box test: 107000 microseconds
branch-free triangle test: 23700 microseconds
*/

//#define BRANCH_FREE_BROADPHASE
#define BRANCH_FREE_TRIANGLES

//tavianator
bool ray_aabb_intersection(Box b, Ray r)
#ifdef BRANCH_FREE_BROADPHASE
{
    float tx1 = (b.mins.x - r.origin.x)*r.inv.x;
    float tx2 = (b.maxs.x - r.origin.x)*r.inv.x;

    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (b.mins.y - r.origin.y)*r.inv.y;
    float ty2 = (b.maxs.y - r.origin.y)*r.inv.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    float tz1 = (b.mins.z - r.origin.z)*r.inv.z;
    float tz2 = (b.maxs.z - r.origin.z)*r.inv.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = max(tmax, max(tz1, tz2));

    return tmax >= tmin;
}
#else
{ 
    float tmin = (b.mins.x - r.origin.x) * r.inv.x; 
    float tmax = (b.maxs.x - r.origin.x) * r.inv.x; 
 
    if (tmin > tmax)
    {
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
    }
 
    float tymin = (b.mins.y - r.origin.y) * r.inv.y; 
    float tymax = (b.maxs.y - r.origin.y) * r.inv.y; 
 
    if (tymin > tymax)
    {
        float tmp = tymin;
        tymin = tymax;
        tymax = tmp;
    }
 
    if ((tmin > tymax) || (tymin > tmax)) 
        return false; 
 
    if (tymin > tmin) 
        tmin = tymin; 
 
    if (tymax < tmax) 
        tmax = tymax; 
 
    float tzmin = (b.mins.z - r.origin.z) * r.inv.z; 
    float tzmax = (b.maxs.z - r.origin.z) * r.inv.z; 
 
    if (tzmin > tzmax)
    {
        float tmp = tzmin;
        tzmin = tzmax;
        tzmax = tmp;
    }
 
    if ((tmin > tzmax) || (tzmin > tmax)) 
        return false; 
 
    if (tzmin > tmin) 
        tmin = tzmin; 
 
    if (tzmax < tmax) 
        tmax = tzmax; 
 
    return true; 
}
#endif

const float EPSILON     = 0.005;
const float SHADOW_BIAS = 0.0005;
const vec3 SUN_DIR = vec3(1.0, 0.0, 0.0);

// Wikipedia Moller-Trumbore algorithm, GLSL-ified and branches removed
bool ray_triangle_intersection(vec3 rayOrigin, vec3 rayVector,
    in Triangle inTriangle, out vec3 outIntersectionPoint)
#ifdef BRANCH_FREE_TRIANGLES
{
    vec3 vertex0 = inTriangle.v0;
    vec3 vertex1 = inTriangle.v1;
    vec3 vertex2 = inTriangle.v2;

    // Results: store all tests and decide return value at the end
    // All of them must be true for the intersection to pass
    bool resultA = true,
         resultB = true,
         resultC = true,
         resultHit = false;

    vec3 edge1, edge2, h, s, q;
    float a,f,u,v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    // Test if ray is parallel to this triangle.
    resultA = !(a > -EPSILON && a < EPSILON);

    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * dot(s, h);
    resultB =  !(u < 0.0 || u > 1.0);

    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    resultC =  !(v < 0.0 || u + v > 1.0);

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    outIntersectionPoint = rayOrigin + rayVector * t;
    resultHit = (t > EPSILON); // ray intersection

    return resultA && resultB && resultC && resultHit;
}
#else
{
    vec3 vertex0 = inTriangle.v0;
    vec3 vertex1 = inTriangle.v1;
    vec3 vertex2 = inTriangle.v2;

    vec3 edge1 = {0.0, 0.0, 0.0};
    vec3 edge2 = {0.0, 0.0, 0.0};
    vec3 h = {0.0, 0.0, 0.0};
    vec3 s = {0.0, 0.0, 0.0};
    vec3 q = {0.0, 0.0, 0.0};
    float a = 0.0, f = 0.0, u = 0.0, v = 0.0;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(rayVector, edge2);
    a = dot(edge1, h);
    // Test if ray is parallel to this triangle.
    if (a > -EPSILON && a < EPSILON)
    {
        return false;
    }

    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    q = cross(s, edge1);
    v = f * dot(rayVector, q);
    if (v < 0.0 || u + v > 1.0)
    {
        return false;
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON) // ray intersection
    {
        outIntersectionPoint = rayOrigin + rayVector * t;
        return true;
    }
    return false;
}
#endif

void store(vec4 rgba)
{
    imageStore(brightnessOut, ivec2(UV), rgba);
}

void store(vec3 rgb)
{
    store(vec4(rgb, 1.0));
}

void draw_circle(ivec2 pos)
{
    vec2 r = vec2(pos - ivec2(UV));
    //float doDraw = 10.0 / length(r);
    float doDraw = 1.0 - step(10.0, length(r));
    store(vec4(vec3(doDraw), 1.0));
}

float light_at_point(vec3 origin)
{
    vec3 direction = SUN_DIR;

    for (uint i = 0; i < OBJ_COUNT; i++)
    {
        ObjectData o = objs[i];
        
        Box aabb;
        aabb.mins = vec3(o.invTransform * vec4(o.aabbMins, 1.0));
        aabb.maxs = vec3(o.invTransform * vec4(o.aabbMaxs, 1.0));

        Ray testRay;
        testRay.origin = vec3(o.invTransform * vec4(origin, 1.0));
        testRay.direction = vec3(o.invTransform * vec4(direction, 0.0));
        testRay.inv = 1.0 / testRay.direction;

        bool hit = ray_aabb_intersection(aabb, testRay);
        if (hit)
        {
            uint start = o.firstTriIndex;
            uint stop = start + o.numTriangles;
            for (uint j = start; j < stop; j++)
            {
                Triangle t = unpack_tri(j);
                vec3 intersect = vec3(0.0);
                bool hitTri = ray_triangle_intersection(testRay.origin, testRay.direction, t, intersect);
                if (hitTri)
                {
                    return 0.0;
                }
            }
        }
    }

    return 1.0;
}

void main()
{
    store(vec4(0.0));

    float depth = texture(gPosDepth, uvf).w;
    if (depth == 1.0) { return; }

    const float HFOV = (3.14159265359/180.0)*45.0;
    const float WIDTH_PX = 1280.0;
    const float HEIGHT_PX = 720.0;
    float VIEW_PLANE_D = (WIDTH_PX/2.0)/tan(HFOV/2.0);
    vec2 rayXY = vec2(UV) - vec2(WIDTH_PX/2.0, HEIGHT_PX/2.0);

    Ray viewRay;
    viewRay.origin = cameraPosWorld;
    viewRay.direction = cameraRot * normalize(vec3(rayXY, -VIEW_PLANE_D));
    viewRay.inv = 1.0 / viewRay.direction;

    vec2 normal2D = texture(gNormalUV, uvf).xy;
    vec3 normal = vec3(normal2D,
        sqrt(1 - normal2D.x*normal2D.x - normal2D.y*normal2D.y));

    // Early normal test
    if (dot(normal, SUN_DIR) < 0.0)
    {
        return;
    }

    vec2 uv = texture(gNormalUV, uvf).zw;

    vec3 fragPos = texture(gPosDepth, uvf).xyz;

    vec3 origin = fragPos + SHADOW_BIAS*normal;
    float val = light_at_point(origin)*dot(normal, SUN_DIR);

    store(vec3(val));

    //imageStore(brightnessOut, ivec2(UV), vec4(ray, 1.0));
}

